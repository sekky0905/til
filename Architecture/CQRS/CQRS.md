# CQRS

## [CQRS Documents by Greg Young](http://www.minato.tv/cqrs/cqrs_documents_jp.pdf)メモ

### ステレオタイプなアーキテクチャ

#### アプリケーションサーバ

- データストレージから分離してビジネスロジックに集中するアーキテクチャが流行ってる

#### クライアントの対話

- クライアントとの対話は、DTOを使用したインタラクティブなやりとり
    - クライアント側でデータを変更→サーバに送信
    - サーバはクライアントから受け取ったDTOをオブジェクトに結びつける
    - DBに格納
    - クライアントからの呼び出しによって、DBのデータをDTOにして返す
- ドメイン駆動設計
    - ドメインオブジェクトに振る舞い(ドメインロジック)を持たせるべきであるが、ドメインオブジェクトは振る舞いを持たない
    - 結局 DTO とマッピングを行うデータの塊のようなものになってしまう
        - ドメインロジックが存在しない場合や、クライアント側に存在する場合、ユーザーの頭の中に存在する場合などがある
        - こういうアーキテクチャは、システムの色んな箇所でデータを編集し、複雑なタスクを完了するための命令が存在する傾向がある

### タスクベース・ユーザインタフェース

- ステレオタイプなアーキテクチャでは、ユーザの目的が失われるという問題点がある
- クライアントとアプリケーションサーバ間の通信は、DTO のやりとりが中心になる
    - ドメインに振る舞いは持つことができない
    - サーバ側には振る舞い (≒ ビジネスロジック)が存在しない
        - クライアントの頭の中とかに存在する
- ユーザーは、データを編集したりするワークフローを持っている
    - 以下のような場合、ソフトウェアは正当な情報を提供することができるか
        - ユーザーが脳内に持っているプロセスのステップを見落とす
        - 異なることを実行する様々なソフトウェアユーザを抱えている
    - 上記のような問題を扱う方法の1つが、DTOの単なるやりとりのアーキテクチャを脱却すること
- 脱却するアーキテクチャ
    - 既存のDTOのやりとりのアーキテクチャとの類似点
        - クライアントがサーバに問い合わせる
        - サーバから指定されたデータの DTO を返す
        - クライアント側で表示する
        - ユーザーとインタラクティブなやりとりが続く
    - 異なる点として、クライアントからサーバにデータを送信する際には、単純な DTO の送信ではなく、ユーザーが何をしたいかという意図もメッセージとして送信する

#### Commands

- サーバが何をするかを伝える方法として用いる
- 処理に必要なデータと、処理の名前を持つ簡易なオブジェクト
- コマンドを「シリアライズ化を行うメソッドの呼び出しとみなす場合も多い
- 以下の例は、[CQRS Documents by Greg Young](http://www.minato.tv/cqrs/cqrs_documents_jp.pdf)に記載されていたコードを Go で書き換えてみた

```go
type DeactivateInventoryItemCommand struct {
    InventoryItemID InventoryItemID
    Comment string
}

// constructor の代わり
func NewDeactivateInventoryItemCommand(id InventoryItemID, comment string) *DeactivateInventoryItemCommand {
    return &DeactivateInventoryItemCommand {
    	InventoryItemID: id,
    	Comment: comment,
    }
}
```

- コマンド名の後にパターン名がある
- 命名方法には賛否両輪あって、軽視するべきものではない
- 常に命令口調
    - 命令口調ということは、サーバは拒否することもできる
    - 拒否できなければ、それはイベント
    - 命令は動詞
    - 目的語が含まれているべき
    - クライアントには、命令が完了した旨の情報を伝えるべき
    - ふるまいの処理に必要な情報だけを持つべき
    - コマンドにはステートを更新する際に対象を指定するための ID が必要
        - コマンドを生成するときは、必ずしも ID に値が格納されている必要はない
    - コマンドの命名を行う時には、使用場面に焦点を当てる必要がある
        - ex) 以下のような違いはないか?
            - Correcting an Address（住所の修正）
            - Relocating the Customer（顧客の再配置)
        - 一般的に、コマンドとユースケースを整理し、ユースケースとコマンドの定義を同時に行うのが最適

### User Interface

- コマンドオブジェクトを構築する必要があるのでユーザの意図がユーザのアクションに由来したものとなるよう UI を設計する
    - 「タスクベース・ユーザーインタフェース(Microsoft 界の「帰納的UI」)
        - 演繹的なUIの問題点
            - ユーザは、
                - インタフェースによるナビゲーションを導くのに十分な完全かつ正確なメンタルモデルを取得していない
                - 一般的な手順をマスターしない
                - 機能や画面を理解するのが困難である
        - タスクベース UI の基本的な考え方
            - ユーザがどのようにソフトウェアを使いたいのかを把握すること
            - プロセスを通して使用方法を導くこと
        - タスクベース・ユーザーインタフェースは
            - ユーザがソフトウェアをなぜ、どのように使用しているのかに焦点を当てる
                - プロセスを導く
                - コンテキストに敏感に沿う形で適切な方向に導く手引きを提供する
        
### コマンドクエリ債務分離

- CQRS
    - CQRSでは以下の2種類にオブジェクトを分類する
        - コマンドを持つオブジェクト
        - クエリを持つオブジェクト
    - ex)
        - 従来のアーキテクチャの例
            - 
            ```
            CustomerService
            void MakeCustomerPreferred(CustomerId)
            Customer GetCustomer(CustomerId)
            CustomerSet GetCustomersWithName(Name)
            CustomerSet GetPreferredCustomers()
            void ChangeCustomerLocale(CustomerId, NewLocale)
            void CreateCustomer(Customer)
            void EditCustomerDetails(CustomerDetails)
            ```
        - 
            - CQRS の例
            ```
            CustomerWriteService
            void MakeCustomerPreferred(CustomerId)
            void ChangeCustomerLocale(CustomerId, NewLocale)
            void CreateCustomer(Customer)
            void EditCustomerDetails(CustomerDetails)

            CustomerReadService
            Customer GetCustomer(CustomerId)
            CustomerSet GetCustomersWithName(Name)
            ```
                - 以下の2種類が存在することがわかる
                    - 書き出し側(コマンド側)
                    - 読み込み側(クエリ側)
        - 上記の例は、[CQRS Documents by Greg Young](http://www.minato.tv/cqrs/cqrs_documents_jp.pdf)から引用
    - 各々の比較
    
    | 種類 | コマンド | クエリ |
    |---|---|---|
    | 一貫性 | 強整合性のトランザクション処理の方が簡単  | 最終的には首尾一貫した処理が可能 |
    | データストレージ | DBのため、正規化したデータを格納することが好まれる  | 非正規化したデータ一式を取得するのが好まれる |
    | スケーラビリティ | 少ない、スケーラビリティ重要でない  | 多い、スケーラビリティ重要 |    
    
    
#### クエリ側

- クライアントが画面に表示するために必要な DTO を取得するメソッドを持つだけ
- クライアントに返却する DTO は
    - クライアントの画面にマッチする DTO を返す
        - 往復の送受信を少なくする
    - DTO モデルはトランザクションの表現や処理を行うため
        - ドメインモデルとは違う
            - ドメインモデルは、オブジェクトモデルでクエリを処理し、データモデルに変換するので最適化が難しい
- CQRS では
    - 経路を明確に分離する
    - DTO を投影するためのドメインが不要になる
    - クエリ側では
        - ドメインを使わずに迂回する
        - 「Thin Read Layer（薄い読み取り層）」を導入
            - データベースから直接読み込み、DTO に投影する
            - Thin Read Layer は、データベースから分離する必要はない
- コマンドとクエリの分離を行うと
    - 同一データモデルからの読み込みにこの 2 つ
     を混在させるべきかどうか、または、2 つの統合化システムとして扱うかという議論を喚起します。
     概要を図12 に示します。一貫
     した方法で複数のデータソース間を同期化するための有名な「統合パターン」が多くあります

#### コマンド側

- コマンド側は、ステレオタイプなアーキテクチャに似ている
    - データの読み込み(クエリ側)を分離している点が異なる
- 一貫した方法で複数のデータソース間を同期化するための「統合パターン」

### ストレージメカニズムにおけるイベント

#### ドメインイベントとは

- ドメインイベント
    - 過去に発生した事柄
    - イベントは、過去形であるべき
    - コマンドとの違い
        - コマンド
            - システムに対して処理を実行するように依頼する意図
        - イベント
            - 発生したアクションを記録するもの
    - 以下の例は、[CQRS Documents by Greg Young](http://www.minato.tv/cqrs/cqrs_documents_jp.pdf)に記載されていたコードを Go で書き換えてみた
    
```go
type InventoryItemDeactivatedEvent struct{
 InventoryItemID InventoryItemID 
 Comment string
}

func NewInventoryItemDeactivatedEvet(id InventoryItemID, comment Comment) *InventoryItemDeactivatedEvent {
    return &InventoryItemDeactivatedEvent{
    	 InventoryItemID: id,  
         Comment: comment,
    }	
}
```

#### ストレージ向けメカニズムとしてのイベント

- ステートを変更していくのではなく、イベントを積み重ねていく
    - 検証可能な関しログになる
    - イベントの値を合計していくことで、最新の値を求めることが可能
    - 過去の任意の時点のステートがどうだったかを確認するのが楽
    - 

#### 削除するものは無い

- リバーサルトランザクション
    - 以下のような場合、A は最終的には、追加されていないことと同じ
    - 1が発生しなかったことにするために3のデータを追加する
        - 1. A を2つ追加する
        - 2. B を3つ追加する
        - 3. A を2つ取り除く
    - リバーサルトランザクションでは、その時点のオブジェクトのステートをログ等に残す
    - データを削除しない利点
        - ストレージシステムに対するアーキテクチャは「追加」だけになる
            - 追加処理は、更新処理よりも楽
                - 更新処理
                    - ロックが必要
                - 追加処理
                    - ロックが不要

#### パフォーマンスとスケーラビリティ

- `append-only` モデルは
    - 性能の利点
    - スケーラビリティの利点
    
##### パーティション分割

- 最近はシャーディングのような水平パーティション分割
    - パーティション分割を実施するためのキーの定義が必要
        - イベントであれば、Aggregate IDs を唯一のパーティションポイントにできる

##### オブジェクトの格納

- RDB を使用しているステレオタイプなシステムでは、アグリゲート内の変更を理解するのが大変
    - ドメインイベント中心のシステムでは、アグリゲートは変更内容に関する強いイベントをトラッキングする

##### オブジェクトのロード

- RDB を使用しているステレオタイプなシステムでは、DB からオブジェクトをロードしてアグリゲートを構築するには、大量のクエリの発行が必要
- ストレージメカニズムとしてイベントに対処する場合には、アグリゲートでは単純に全てのイベントをロードして再生するだけ

##### スナップショットの巻き出し

- Rolling Snapshot
    - その時点のアグリゲートの現在のステートを非正規化したもの
    - すべてのイベントがその時点までに再生したときのステート
    - アグリゲートの完全な履歴を取得するにはすべてのイベントをロードする必要があるがその回避策
    - アグリゲートをロードするために前方に向かって時間を追ってイベントを再生する
    - イベントがあるスタックをイベントが無くなるかスナップショットが見つかるまで、逆方向に読み込む
    - イベントはスタックが空になるまで、スタックから取り出して適用する
    - 実装ではこれは理想ではない
    
##### インピーダンス・ミスマッチ

- RDB モデルとオブジェクト指向ドメインモデルの間にはインピーダンスミスマッチが存在する
- イベントとドメインモデルの間にはインピーダンスミスマッチはない
    - イベントはそれ自体がドメイン概念
    
## イベントログのビジネス価値

- 従来のモデルでは「What」が重要視される
- ビジネスでは「How」も注目されている
    - 「何が発生したか」ではなく「どのように発生したか」
        - イベントではこれを参照できる

#### ドメインイベントとは

- イベントとは、過去に発生した事柄
    - イベントは過去形の動詞で表す
- イベントをコードのすると以下のような感じ
- 以下の例は、[CQRS Documents by Greg Young](http://www.minato.tv/cqrs/cqrs_documents_jp.pdf)に記載されていたコードを Go で書き換えてみ    

```go
type InventoryItemDeactivatedEvent struct {
    InventoryItemID InventoryItemID
    Comment string
}

func NewInventoryItemDeactivatedEvent(id InventoryItemID, comment string)*InventoryItemDeactivatedEvent{
    return &InventoryItemDeactivatedEvent{
    	    InventoryItemID: id,
            Comment: comment, 
    }
}
```

- コマンドとイベントの違い
    - コマンド
        - システムに対し、処理を実行するように依頼する意図がある
    - イベント
        - 発生したアクションを記録するもの

#### 削除するものはない

- リバーサルトランザクション
    - イベントストリーム上で、`Add X` → `Remove X` というようなことを行ったとする
        - この場合、最初のイベント( `Add X` )をなかったことにするために、 新しいデータ ( `Remove X` )をつい買うする
            - 上記の処理がリバーサルトランザクション
- データの削除を行わない利点
    - ストレージに対するアーキテクチャが「追加」だけになる
        - `append-only` アーキテクチャ
        - 更新処理よりも簡単
        - 更新処理にはロックが必要だが、追加処理にはロックが不要だから

#### パフォーマンスとスケーラビリティ

- `append-only` モデルでは
    - イベントの格納はスケーリングが簡単
    - 性能の利点
- RDB で水平パーテション分割を行う際の問題点の1つが、水平パーテション分割のためのキーの定義
    - イベントでは、 `Aggregate IDs` がシステムにおける唯一のパーテションポイント
    
#### オブジェクトのロード

- RDB を利用するステレオタイプなシステムでは、オブジェクトをロードする際にはアグリゲートを構築するために大量のクエリの発行が必要
- ストレージメカニズムとしてイベントに対処する際には、格納するのはイベント
    - アグリゲートでは単純に全てのイベントをロードして再生する

#### スナップショットの巻き戻し

- Rolling Snapshot
    - その時点のアグリゲートの現在のステートを非正規化したもの
    - 全てのイベントがその時点までに再生した時のステートを表す
    - アグリゲートの完全n履歴を取得するには全てのイベントをロードする必要がある
        - それを回避するために `Rolling Snapshot` を使用する
    - イベントがあるスタックをイベントがなくなるかスナップショットが見つかるまで逆方向に読み込む
        - スナップショットが見つかればそれを適用する
        - イベントはスタックが空になるまでスタックかr取り出して適用する 


### 参考

- [CQRS Documents by Greg Young](http://www.minato.tv/cqrs/cqrs_documents_jp.pdf)
